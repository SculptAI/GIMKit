<!DOCTYPE html>
<html>

<head>
    <title>JSONL Data Viewer</title>
    <meta charset="UTF-8">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/vue@3.2.31"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        .card {
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .filename {
            color: #6c757d;
            font-size: 0.9rem;
            margin-left: 10px;
        }

        .message-content {
            white-space: pre-wrap;
        }

        .drag-area {
            border: 2px dashed #007bff;
            border-radius: 10px;
            padding: 40px;
            background-color: #f8f9fa;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .drag-area:hover {
            background-color: #e9ecef;
            border-color: #0056b3;
        }

        .drag-area.dragover {
            background-color: #d4edda;
            border-color: #28a745;
        }
    </style>
</head>

<body>
    <div id="app" class="container mt-4">
        <!-- File Selection -->
        <div v-if="!fileLoaded" class="text-center">
            <h2>JSONL Data Viewer</h2>
            <div class="drag-area mb-3" :class="{ 'dragover': isDragOver }" @click="$refs.fileInput.click()"
                @dragover.prevent="handleDragOver" @dragleave.prevent="handleDragLeave" @drop.prevent="handleDrop">
                <div class="mb-3">
                    <div style="font-size: 3rem; margin-bottom: 1rem;">üìÅ</div>
                    <h5>Click to select or drag & drop JSONL file</h5>
                    <p class="text-muted small">Supports m_input/m_output, m_query/m_response, or messages format</p>
                </div>
                <input type="file" ref="fileInput" @change="loadFile" accept=".jsonl" class="d-none">
            </div>
        </div>

        <!-- Data Viewer -->
        <div v-else>
            <div class="d-flex justify-content-between align-items-center">
                <div>
                    <h2 class="d-inline">JSONL Data Viewer</h2>
                    <span v-if="filename" class="filename">({{ filename }})</span>
                </div>
                <div class="form-check form-switch">
                    <input class="form-check-input" type="checkbox" v-model="latexMode" @change="handleModeChange">
                    <label class="form-check-label">LaTeX Mode</label>
                </div>
            </div>

            <!-- Pagination - Moved here -->
            <div class="d-flex justify-content-between align-items-center my-3">
                <button @click="prevPage" :disabled="currentIndex === 0" class="btn btn-primary">Previous</button>
                <div>
                    <input type="number" v-model.number="jumpToPage" min="1" :max="totalItems"
                        class="form-control d-inline" style="width: 80px">
                    <span> / {{ totalItems }}</span>
                </div>
                <button @click="nextPage" :disabled="currentIndex >= totalItems - 1"
                    class="btn btn-primary">Next</button>
            </div>

            <!-- Data Card -->
            <div class="card" v-if="currentItem">
                <div class="card-body">
                    <!-- Check if it's the new query/response format (m_query/m_response) -->
                    <div v-if="currentItem.m_query && currentItem.m_response">
                        <div class="mb-3">
                            <strong style="color: #dc3545;">QUERY</strong>
                            <div v-html="formatContent(currentItem.m_query)" class="message-content"></div>
                        </div>
                        <div class="mb-3">
                            <strong style="color: #198754;">RESPONSE</strong>
                            <div v-html="formatContent(currentItem.m_response)" class="message-content"></div>
                        </div>
                    </div>
                    <!-- Check if it's the legacy format (m_input/m_output) -->
                    <div v-else-if="currentItem.m_input && currentItem.m_output">
                        <div class="mb-3">
                            <strong style="color: #dc3545;">INPUT</strong>
                            <div v-html="formatContent(currentItem.m_input)" class="message-content"></div>
                        </div>
                        <div class="mb-3">
                            <strong style="color: #198754;">OUTPUT</strong>
                            <div v-html="formatContent(currentItem.m_output)" class="message-content"></div>
                        </div>
                    </div>
                    <!-- Original format (messages array) -->
                    <div v-else-if="currentItem.messages">
                        <div v-for="(message, idx) in currentItem.messages" :key="idx" class="mb-3">
                            <strong style="color: #2563eb;">{{ message.role.toUpperCase() }}</strong>
                            <div v-html="formatContent(message.content)" class="message-content"></div>
                        </div>
                    </div>
                    <!-- Fallback for unknown format -->
                    <div v-else>
                        <pre>{{ JSON.stringify(currentItem, null, 2) }}</pre>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const app = Vue.createApp({
            data() {
                return {
                    items: [],
                    currentIndex: 0,
                    fileLoaded: false,
                    latexMode: false,
                    jumpToPage: 1,
                    filename: '',
                    isDragOver: false
                }
            },
            computed: {
                currentItem() {
                    return this.items[this.currentIndex]
                },
                totalItems() {
                    return this.items.length
                }
            },
            methods: {
                loadFile(event) {
                    const file = event.target.files[0]
                    if (!file) return
                    this.processFile(file)
                },
                handleDragOver(event) {
                    this.isDragOver = true
                },
                handleDragLeave(event) {
                    this.isDragOver = false
                },
                handleDrop(event) {
                    this.isDragOver = false
                    const files = event.dataTransfer.files
                    if (files.length > 0) {
                        this.processFile(files[0])
                    }
                },
                processFile(file) {
                    if (!file.name.toLowerCase().endsWith('.jsonl')) {
                        alert('Please select a .jsonl format file')
                        return
                    }

                    this.filename = file.name

                    const reader = new FileReader()
                    reader.onload = (e) => {
                        const content = e.target.result
                        this.processFileContent(content, file.name);
                    }
                    reader.readAsText(file)
                },
                processFileContent(content, filename) {
                    this.items = content.trim().split('\n')
                        .map(line => {
                            try {
                                return JSON.parse(line)
                            } catch (error) {
                                console.error('Error parsing line:', line)
                                return null
                            }
                        })
                        .filter(item => item !== null)
                    this.fileLoaded = true
                    this.currentIndex = 0
                    this.jumpToPage = 1
                    this.filename = filename
                    if (this.latexMode) this.updateMathJax()
                },
                handleModeChange() {
                    // Force content refresh
                    const currentContent = this.currentItem;
                    this.currentItem = null;
                    this.$nextTick(() => {
                        this.currentItem = currentContent;
                        if (this.latexMode) {
                            this.updateMathJax();
                        }
                    });
                },
                formatContent(content) {
                    let formatted = content
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/\n/g, '<br>');

                    if (this.latexMode) {
                        formatted = formatted
                            .replace(/\\\(/g, '\\(')
                            .replace(/\\\)/g, '\\)')
                            .replace(/\\\[/g, '\\[')
                            .replace(/\\\]/g, '\\]');
                    } else {
                        formatted = formatted
                            .replace(/\\\(/g, '$')
                            .replace(/\\\)/g, '$')
                            .replace(/\\\[/g, '$$')
                            .replace(/\\\]/g, '$$');
                    }
                    return formatted;
                },
                prevPage() {
                    if (this.currentIndex > 0) {
                        this.currentIndex--
                        this.jumpToPage = this.currentIndex + 1
                        if (this.latexMode) this.updateMathJax()
                    }
                },
                nextPage() {
                    if (this.currentIndex < this.items.length - 1) {
                        this.currentIndex++
                        this.jumpToPage = this.currentIndex + 1
                        if (this.latexMode) this.updateMathJax()
                    }
                },
                updateMathJax() {
                    if (this.latexMode) {
                        setTimeout(() => {
                            MathJax.typesetPromise()
                        }, 100)
                    }
                }
            },
            watch: {
                jumpToPage(newVal) {
                    const page = parseInt(newVal)
                    if (page >= 1 && page <= this.totalItems) {
                        this.currentIndex = page - 1
                        if (this.latexMode) this.updateMathJax()
                    }
                }
            }
        }).mount('#app')
    </script>
</body>

</html>
